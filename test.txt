//opencv_line_detect.cpp
//-I/usr/local/include/opencv4/opencv -I/usr/local/include/opencv4

#define LEFT    -1
#define CENTER   0
#define RIGHT    1

#include <ros/ros.h>
#include "std_msgs/String.h"
#include "std_msgs/Bool.h"
#include "std_msgs/Int8.h"
#include "std_msgs/Int16.h"
#include "std_msgs/Float32.h"
#include "image_transport/image_transport.h"
#include "cv_bridge/cv_bridge.h"
#include "sensor_msgs/Image.h"

#include <opencv2/opencv.hpp>
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <errno.h>

using namespace cv;
using namespace std;

#define IMG_Width     640
#define IMG_Height    360

#define USE_DEBUG  1   // 1 디버그 사용
#define USE_CAMERA 1   // 1 카메라 사용, 0 카메라 미사용

#define NO_LINE 300
#define MAX_STEER_ANGLE  30

Mat mat_image_org_color;  // 이미지 저장 변수
Mat mat_image_org_color_crop;
Mat mat_image_org_gray;
Mat mat_image_roi_crop;
Mat mat_image_canny_edge;
Mat mat_image_canny_edge1;
//Mat mat_image_canny_edge_roi;
Mat mat_image_roi_gray;
Mat mat_image_roi_gray_crop;
Mat mat_image_roi_threshold;

Scalar GREEN(0, 255, 0);
Scalar RED(0, 0, 255);
Scalar BLUE(255, 0, 0);
Scalar YELLOW(0, 255, 255);
Scalar ORANGE(0,165,255);

int img_width    = 640;
int img_height   = 360;
int ROI_CENTER_Y = 180;
int ROI_WIDTH    =  30;
int canney_low   =  50;
int canney_high  = 170;

//////////////////////////////////////// PID 제어 ////////////////////////////////////////////////

bool   lane_control_run_set = false;
bool   avoid_control_enable_flag = false;
bool   stop_flag = false;
int    car_avoid_steer_direction = CENTER;

double lane_width = 300;
double vision_xte_offset = 0.0;

struct Rect_Region
{
	int left;
	int right;
	int top;
	int bottom;
};

struct Rect_Region ROI_lane;

void avoid_control_enable_Callback(const std_msgs::Bool& msg)
{
	avoid_control_enable_flag = msg.data;
}

void car_avoid_steer_directoin_Callback(const std_msgs::Int8& msg)
{
	car_avoid_steer_direction = msg.data;
}

void stop_flag_Callback(const std_msgs::Bool& msg)
{
	stop_flag = msg.data;
}

void CamImageCallback(const sensor_msgs::Image::ConstPtr& msg)
{
}

void vision_xte_offset_topic_Callback(const std_msgs::Float32& msg)
{
	vision_xte_offset = msg.data;
}

void run_lane_control_flagCallback(const std_msgs::Bool& msg)
{
	lane_control_run_set = msg.data;
}

Mat Region_of_Interest(Mat image, Point* points)
{
    Mat img_mask = Mat::zeros(image.rows, image.cols, CV_8UC1);
    Scalar mask_color = Scalar(255, 255, 255);
    const Point* pt[1] = { points };
    int npt[] = { 4 };
    cv::fillPoly(img_mask, pt, npt, 1, Scalar(255, 255, 255), LINE_8);
    Mat masked_img;
    bitwise_and(image, img_mask, masked_img);
    return masked_img;
}

Mat Region_of_Interest_crop(Mat image, Point* points)
{
    Mat img_roi_crop_temp;
    Mat image2;
    image.copyTo(image2);
    Rect bounds(0, 0, image2.cols, image2.rows);
    Rect r(points[0].x, points[0].y, points[2].x-points[0].x, points[2].y - points[0].y);
    img_roi_crop_temp = image2(r & bounds);
    return img_roi_crop_temp;
}

Mat Canny_Edge_Detection(Mat img)
{
    Mat mat_blur_img, mat_canny_img;
    blur(img, mat_blur_img, Size(3, 3));
    Canny(mat_blur_img, mat_canny_img, canney_low, canney_high, 3);
    return mat_canny_img;
}

double line_blob_detection(Mat mat_img_crop)
{
	int max_area   = -1;
	int max_area_i = -1;
	cvtColor(mat_img_crop, mat_image_roi_gray, cv::COLOR_RGB2GRAY);
	erode(mat_image_roi_threshold, mat_image_roi_threshold, Mat::ones(Size(3,3),CV_8UC1),Point(-1,-1),1);
	Mat img_labels,stats, centroids;
	int numOfLables = connectedComponentsWithStats(mat_image_roi_threshold, img_labels, stats, centroids, 8,CV_32S);
	for (int i = 1; i < numOfLables; i++)
	{
		 int left  = stats.at<int>(i,CC_STAT_LEFT);
		 int width = stats.at<int>(i,CC_STAT_WIDTH);
		 int area  = stats.at<int>(i,CC_STAT_AREA);
		 if(area > max_area)
		 {
			max_area   = area;
			max_area_i = i;
		 }
	}
	if(max_area_i != -1)
	{
		double x = centroids.at<double>(max_area_i, 0);
		double y = centroids.at<double>(max_area_i, 1);
		printf("최대 블롭 위치 : [%4.1lf ,%4.1lf]\n", x,y);
		return x;
	}
	else
	{
		return -1;
	}
}

int main(int argc, char** argv)
{
	/////////////////// 카메라 이미지는 640x360으로 고정 (Jetson Nano) ////////////////////////

	int i;

	double gradient[NO_LINE]        = { 0, };
	double intersect_x[NO_LINE]     = { 0, };
	double intersect_left[NO_LINE]  = { 0, };
	double intersect_right[NO_LINE] = { 0, };

	double c_x_sum = 0;

	int capture_width  = 640; 
	int capture_height = 360;
	int display_width  = 640;
	int display_height = 360;
	int framerate     = 60;
	int flip_method   = 2;
	int left_line_no  = 0;
	int right_line_no = 0;

	double  c[NO_LINE] = { 0.0, };
	double  d[NO_LINE] = { 0.0, };

	double  valid_c[NO_LINE] = { 0.0, };
	double  valid_d[NO_LINE] = { 0.0, };

	double  line_left_x  = 0.0;
	double  line_right_x = 0.0;

	double steer_angle_old, steer_angle_new;
	double *euclidean_distance_matrix; 
	double line_center = -1;

	int perspective_upper = 137;
	int perspective_lower = 319;

	steer_angle_old =  steer_angle_new = 0.0;
	ros::init(argc, argv, "ros_lane_control");

	ros::NodeHandle nh;

	int img_width  = 640;
	int img_height = 360;

	std::string input_image_topic           = "/usb_cam/image_raw";
	std::string vision_xte_offset_topic     = "/vision_xte_offset";
	std::string vision_xte_topic            = "/vision_xte";
	std::string speed_topic                 = "/Car_Control_cmd/Speed_Int16";

	ros::param::get("~input_image_topic",input_image_topic);
	ros::param::get("~img_width",     img_width);
	ros::param::get("~img_height",    img_height);
	ros::param::get("~ROI_CENTER_Y",  ROI_CENTER_Y);
	ros::param::get("~ROI_WIDTH",     ROI_WIDTH);
	ros::param::get("~perspective_upper",     perspective_upper);
	ros::param::get("~perspective_lower",     perspective_lower);
	ros::param::get("~lane_width",    lane_width);
	ros::param::get("~canney_low",    canney_low);
	ros::param::get("~canney_high" ,  canney_high);
	ros::param::get("~vision_xte_topic",vision_xte_topic);
	ros::param::get("~vision_xte_offset_topic",vision_xte_offset_topic);

    ros::Subscriber image_sub                       = nh.subscribe(input_image_topic, 1, &CamImageCallback);
	ros::Subscriber run_lane_control_flag_sub       = nh.subscribe("/flag/lane_control_set",1, &run_lane_control_flagCallback);
	ros::Subscriber cmd_vel_vision_xte__sub         = nh.subscribe(vision_xte_offset_topic,1, &vision_xte_offset_topic_Callback);
	ros::Subscriber avoid_control_enable_sub        = nh.subscribe("/flag/avoid_control_lane_enable",1, &avoid_control_enable_Callback);
	ros::Subscriber stop_flag_sub                   = nh.subscribe("/vision/stop_line_detect_flag",1,&stop_flag_Callback);
	ros::Subscriber car_avoid_steer_directoin_sub   = nh.subscribe("/Car_Control_Cmd/avoid_direction", 1,&car_avoid_steer_directoin_Callback);

	ros::Publisher speed_pub                        = nh.advertise<std_msgs::Int16>(speed_topic,1);
	ros::Publisher cross_track_error_pub            = nh.advertise<std_msgs::Float32>(vision_xte_topic,1);
	ros::Rate loop_rate(20);

	int count = 0;
	ROI_lane.left  = 0;
	ROI_lane.right = img_width -1;
	ROI_lane.top   = (img_height - perspective_upper)/2;
	ROI_lane.bottom= (img_height - perspective_lower)/2;

	while(ros::ok())
	{
		if(mat_image_org_color.empty())
		{
			ros::spinOnce();
			loop_rate.sleep();
			++count;
			continue;
		}

		if(lane_control_run_set)
		{
			if(stop_flag)
			{
				std_msgs::Int16 speed_msg;
				speed_msg.data = 0;
				speed_pub.publish(speed_msg);
				printf("정지 신호 발견!!\n");
			}
			else if(avoid_control_enable_flag)
			{
				std_msgs::Int16 speed_msg;
				speed_msg.data = 0;
				speed_pub.publish(speed_msg);
				printf("회피 제어 신호 발견\n");
			}
			else
			{
				mat_image_org_color.copyTo(mat_image_org_color_crop);
				Point points[4];
				points[0] = Point(0, (img_height - perspective_upper)/2);
				points[1] = Point(0, (img_height - perspective_lower)/2);
				points[2] = Point(img_width, (img_height - perspective_lower)/2);
				points[3] = Point(img_width, (img_height - perspective_upper)/2);

				mat_image_roi_crop = Region_of_Interest_crop(mat_image_org_color, points);
				mat_image_canny_edge = Canny_Edge_Detection(mat_image_roi_crop);

				vector<Vec4i> linesP;
				HoughLinesP(mat_image_canny_edge, linesP, 1, CV_PI/180, 30, 30, 20);
				printf("검출된 직선 개수 : %3ld \n", linesP.size());

				int j = 0;
				for( i = 0; i < linesP.size(); i++ )
				{
					Vec4i L = linesP[i];
					double dx, dy;

					dx = L[2] - L[0];
					dy = L[3] - L[1];
					if (dx == 0)
					{
						continue;
					}
					double c1 = dy / dx; 
					double d1 = L[0]; 

					if(fabs(c1) < 0.5)
					{
						continue;
					}

					gradient[j] = c1; 
					intersect_x[j] = d1;

					Point pt1(L[0], L[1]);
					Point pt2(L[2], L[3]);
					line(mat_image_roi_crop, pt1, pt2, Scalar(255, 0, 0), 1, LINE_AA);
					j++;
				}

				left_line_no = 0;
				right_line_no = 0;
				double left_line_c = 0;
				double left_line_d = 0;
				double right_line_c = 0;
				double right_line_d = 0;

				for(i = 0; i < j; i++)
				{
					if(gradient[i] < 0)
					{
						intersect_left[left_line_no] = intersect_x[i];
						left_line_no++;
					}
					else
					{
						intersect_right[right_line_no] = intersect_x[i];
						right_line_no++;
					}
				}

				if(left_line_no > 0)
				{
					left_line_c = (left_line_no == 0) ? 0 : std::accumulate(gradient, gradient + left_line_no, 0.0) / left_line_no;
					left_line_d = (left_line_no == 0) ? 0 : std::accumulate(intersect_left, intersect_left + left_line_no, 0.0) / left_line_no;
					double y1 = 10;
					double x1 = left_line_c * y1 + left_line_d;
					double y2 = ROI_WIDTH * 2 - 10;
					double x2 = left_line_c * y2 + left_line_d;
					line(mat_image_roi_crop, Point(x1, y1), Point(x2, y2), Scalar(0, 255, 255), 2, LINE_AA);
					double y3 = (double)ROI_WIDTH;
					double x3 = left_line_c * y3 + left_line_d;
					printf("왼쪽 선 : x3, y3 | %5.1lf  %5.1lf %5.1lf  %5.1lf  \n", x3, y3, left_line_c, left_line_d);
					circle(mat_image_roi_crop, Point(x3, y3), 5, Scalar(0, 255, 255), -1);
					line_left_x = x3;
				}

				if(right_line_no > 0)
				{
					right_line_c = (right_line_no == 0) ? 0 : std::accumulate(gradient, gradient + right_line_no, 0.0) / right_line_no;
					right_line_d = (right_line_no == 0) ? 0 : std::accumulate(intersect_right, intersect_right + right_line_no, 0.0) / right_line_no;
					double y1 = 10;
					double x1 = right_line_c * y1 + right_line_d;
					double y2 = ROI_WIDTH * 2 - 10;
					double x2 = right_line_c * y2 + right_line_d;
					line(mat_image_roi_crop, Point(x1, y1), Point(x2, y2), Scalar(255, 0, 255), 2, LINE_AA);
					double y3 = (double)ROI_WIDTH;
					double x3 = right_line_c * y3 + right_line_d;
					printf("오른쪽 선 : x3, y3 | %5.1lf  %5.1lf %5.1lf  %5.1lf  \n", x3, y3, right_line_c, right_line_d);
					circle(mat_image_roi_crop, Point(x3, y3), 5, Scalar(255, 0, 255), -1);
					line_right_x = x3;
				}

				if(left_line_no != 0 && right_line_no != 0)
				{
					line_center = (line_left_x + line_right_x) / 2.0;
					c_x_sum = line_center - img_width / 2.0;
				}
				else if(left_line_no != 0 && right_line_no == 0)
				{
					line_center = line_left_x + lane_width / 2.0;
					c_x_sum = line_center - img_width / 2.0;
				}
				else if(left_line_no == 0 && right_line_no != 0)
				{
					line_center = line_right_x - lane_width / 2.0;
					c_x_sum = line_center - img_width / 2.0;
				}
				else
				{
					line_center = -1;
					c_x_sum = 0;
				}

				printf("차선 중심 : %5.1lf   c_x_sum : %5.1lf \n", line_center, c_x_sum);

				std_msgs::Float32 cross_track_error_msg;
				cross_track_error_msg.data = c_x_sum + vision_xte_offset;
				cross_track_error_pub.publish(cross_track_error_msg);

				printf("크로스 트랙 에러  : %6.3lf\n", cross_track_error_msg.data);
				printf("차선 크로스 트랙 오프셋 : %6.3lf\n", vision_xte_offset);

				imshow("ROI 이미지 창", mat_image_roi_crop);
			}
		}

		ros::spinOnce();
		loop_rate.sleep();
		++count;
	}

	return 0;
}

<launch>

   <!-- <node pkg="ros_lane_control" type = "vision_xte_offset.py" name = "vision_xte_offset.py" output="screen"/> -->
	 <node pkg="aa10_ros_lane_control" type = "aa10_ros_lane_control_node" name = "aa10_ros_lane_control_node" output="screen">
	
		
		<param name= "input_image_topic"                  type = "string"          value = "/camera/image1"/>     <!-- image topic -->
		<param name= "img_width"                          type = "int"             value = "640"/>                    <!-- image size height -->
		<param name= "img_height"                         type = "int"             value = "360"/>                    <!-- image size widht -->        
		<param name= "lane_width"                         type = "double"          value = "560"/>                    <!-- 100 -->
		
		<param name= "ROI_CENTER_Y"                       type = "int"             value =  "220"/>                    <!-- ROI center locaton -->          
		<param name= "ROI_WIDTH"                          type = "int"             value =  "50"/>                    <!-- ROI height size -->  
		
		<param name= "perspective_upper"                  type = "int"             value =  "280"/>                   <!-- bird eye roi upper value200 225-->
		<param name= "perspective_lower"                  type = "int"             value =  "370"/>                   <!-- bird eye roi lower value319 530-->      
		
		<param name= "canney_low"                         type = "int"             value =  "110"/>                    <!-- canney edeg parameter  -->
		<param name= "canney_high"                        type = "int"             value =  "170"/>                   <!-- 90, 170 -->
		
		<param name= "cmd_vel_vision_output_topic"        type = "string"          value = "/cmd_vel/vision"/> 
		
       
		<param name= "vision_xte_topic"                   type = "string"          value = "/xte/vision"/>
		<param name= "vision_xte_offset_topic"            type = "string"          value = "/xte/vision_offset"/> 
		
	</node>   
</launch>

