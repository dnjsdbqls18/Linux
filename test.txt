#include <ros/ros.h>
#include "std_msgs/String.h"
#include "std_msgs/Bool.h"
#include "std_msgs/Int8.h"
#include "std_msgs/Int16.h"
#include "std_msgs/Float32.h"
#include "image_transport/image_transport.h"
#include "cv_bridge/cv_bridge.h"
#include "sensor_msgs/Image.h"

#include <opencv2/opencv.hpp>
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <errno.h>
#include <numeric>

using namespace cv;
using namespace std;

#define IMG_Width     640
#define IMG_Height    360

#define USE_DEBUG  1   // 디버그 사용
#define USE_CAMERA 1   // 카메라 사용

#define NO_LINE 300
#define MAX_STEER_ANGLE  30

Mat mat_image_org_color;  // 원본 이미지 저장 변수
Mat mat_image_org_color_crop;
Mat mat_image_org_gray;
Mat mat_image_roi_crop;
Mat mat_image_canny_edge;
Mat mat_image_canny_edge1;
Mat mat_image_roi_gray;
Mat mat_image_roi_gray_crop;
Mat mat_image_roi_threshold;

Scalar GREEN(0, 255, 0);
Scalar RED(0, 0, 255);
Scalar BLUE(255, 0, 0);
Scalar YELLOW(0, 255, 255);
Scalar ORANGE(0,165,255);

int img_width    = 640;
int img_height   = 360;
int ROI_CENTER_Y = 180;
int ROI_WIDTH    =  30;
int canney_low   =  50;
int canney_high  = 170;

//////////////////////////////////////// PID 제어 ////////////////////////////////////////////////

bool   lane_control_run_set = false;
bool   avoid_control_enable_flag = false;
bool   stop_flag = false;
int    car_avoid_steer_direction = CENTER;

double lane_width = 300;
double vision_xte_offset = 0.0;

struct Rect_Region
{
    int left;
    int right;
    int top;
    int bottom;
};

struct Rect_Region ROI_lane;

void avoid_control_enable_Callback(const std_msgs::Bool& msg)
{
    avoid_control_enable_flag = msg.data;
}

void car_avoid_steer_directoin_Callback(const std_msgs::Int8& msg)
{
    car_avoid_steer_direction = msg.data;
}

void stop_flag_Callback(const std_msgs::Bool& msg)
{
    stop_flag = msg.data;
}

void CamImageCallback(const sensor_msgs::Image::ConstPtr& msg)
{
    // 이미지 처리 함수
}

void vision_xte_offset_topic_Callback(const std_msgs::Float32& msg)
{
    vision_xte_offset = msg.data;
}

void run_lane_control_flagCallback(const std_msgs::Bool& msg)
{
    lane_control_run_set = msg.data;
}

Mat Region_of_Interest(Mat image, Point* points)
{
    Mat img_mask = Mat::zeros(image.rows, image.cols, CV_8UC1);
    Scalar mask_color = Scalar(255, 255, 255);
    const Point* pt[1] = { points };
    int npt[] = { 4 };
    fillPoly(img_mask, pt, npt, 1, Scalar(255, 255, 255), LINE_8);
    Mat masked_img;
    bitwise_and(image, img_mask, masked_img);
    return masked_img;
}

Mat Region_of_Interest_crop(Mat image, Point* points)
{
    Mat img_roi_crop_temp;
    Mat image2;
    image.copyTo(image2);
    Rect bounds(0, 0, image2.cols, image2.rows);
    Rect r(points[0].x, points[0].y, points[2].x-points[0].x, points[2].y - points[0].y);
    img_roi_crop_temp = image2(r & bounds);
    return img_roi_crop_temp;
}

Mat Canny_Edge_Detection(Mat img)
{
    Mat mat_blur_img, mat_canny_img;
    blur(img, mat_blur_img, Size(3, 3));
    Canny(mat_blur_img, mat_canny_img, canney_low, canney_high, 3);
    return mat_canny_img;
}

double line_blob_detection(Mat mat_img_crop)
{
    int max_area   = -1;
    int max_area_i = -1;
    Mat mat_image_roi_gray;
    cvtColor(mat_img_crop, mat_image_roi_gray, COLOR_BGR2GRAY);
    Mat mat_image_roi_threshold;
    threshold(mat_image_roi_gray, mat_image_roi_threshold, 100, 255, THRESH_BINARY);

    erode(mat_image_roi_threshold, mat_image_roi_threshold, Mat::ones(Size(3,3),CV_8UC1),Point(-1,-1),1);

    Mat img_labels,stats, centroids;
    int numOfLables = connectedComponentsWithStats(mat_image_roi_threshold, img_labels, stats, centroids, 8, CV_32S);

    for (int i = 1; i < numOfLables; i++)
    {
        int area  = stats.at<int>(i, CC_STAT_AREA);
        if(area > max_area)
        {
            max_area   = area;
            max_area_i = i;
        }
    }

    if(max_area_i != -1)
    {
        double x = centroids.at<double>(max_area_i, 0);
        double y = centroids.at<double>(max_area_i, 1);
        printf("최대 블롭 위치 : [%4.1lf ,%4.1lf]\n", x, y);
        return x;
    }
    else
    {
        return -1;
    }
}

int main(int argc, char** argv)
{
    ros::init(argc, argv, "ros_lane_control");
    ros::NodeHandle nh;

    ros::Subscriber image_sub                       = nh.subscribe("/usb_cam/image_raw", 1, &CamImageCallback);
    ros::Subscriber run_lane_control_flag_sub       = nh.subscribe("/flag/lane_control_set", 1, &run_lane_control_flagCallback);
    ros::Subscriber cmd_vel_vision_xte__sub         = nh.subscribe("/xte/vision_offset", 1, &vision_xte_offset_topic_Callback);
    ros::Subscriber avoid_control_enable_sub        = nh.subscribe("/flag/avoid_control_lane_enable", 1, &avoid_control_enable_Callback);
    ros::Subscriber stop_flag_sub                   = nh.subscribe("/vision/stop_line_detect_flag", 1, &stop_flag_Callback);
    ros::Subscriber car_avoid_steer_directoin_sub   = nh.subscribe("/flag/car_avoid_steer_direction", 1, &car_avoid_steer_directoin_Callback);

    ros::Publisher pub_steerAngle = nh.advertise<std_msgs::Int16>("/manual_control/steering", 10);

    ROS_INFO("Manual Control steering Angle Publishing Start");

    ros::Rate loop_rate(10);
    while (ros::ok())
    {
        if (lane_control_run_set)
        {
            Point pts1[4] =
            {
                Point(ROI_CENTER_Y - ROI_WIDTH, 137),
                Point(ROI_CENTER_Y + ROI_WIDTH, 137),
                Point(ROI_CENTER_Y + ROI_WIDTH, 319),
                Point(ROI_CENTER_Y - ROI_WIDTH, 319)
            };

            mat_image_org_color_crop = Region_of_Interest_crop(mat_image_org_color, pts1);

            if (!mat_image_org_color_crop.empty())
            {
                mat_image_org_gray = Canny_Edge_Detection(mat_image_org_color_crop);

                Mat mat_image_roi_crop = Region_of_Interest(mat_image_org_color, pts1);

                if (!mat_image_roi_crop.empty())
                {
                    double x_position = line_blob_detection(mat_image_roi_crop);

                    double relative_x_position = (IMG_Width / 2) - x_position;
                    double angle = atan2(relative_x_position, IMG_Width * 3) * 180 / CV_PI;

                    ROS_INFO("angle : [%lf]", angle);

                    std_msgs::Int16 msg_steerAngle;
                    msg_steerAngle.data = angle;
                    pub_steerAngle.publish(msg_steerAngle);
                }
                else
                {
                    ROS_INFO("mat_image_roi_crop is empty");
                }
            }
            else
            {
                ROS_INFO("mat_image_org_color_crop is empty");
            }
        }
        else
        {
            ROS_INFO("Flag is not set");
        }

        ros::spinOnce();
        loop_rate.sleep();
    }

    return 0;
}
